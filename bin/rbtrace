#!/usr/bin/env ruby
require 'rubygems'
require 'ffi'

def process_line(line)
  @tracers ||= {}
  @nesting ||= 0
  @last_tracer ||= nil

  time, event, id, *args = line.strip.split(',')
  time = time.to_i
  id = id.to_i
  tracer = @tracers[id]

  case event
  when 'add'
    if id == -1
      puts line
    else
      name = args.first
      @tracers[id] = {
        :name => name,
        :times => [],
        :ctimes => []
      }
    end

  when 'remove'
    if id == -1
      puts line
    else
      @tracers.delete(id)
    end

  when 'call','ccall'
    method, is_singleton, klass = *args
    is_singleton = (is_singleton == '1')
    bucket = (event == 'call' ? :times : :ctimes)

    tracer[bucket] << time

    puts
    if @nesting > 0
      print '   '*@nesting
    end
    print klass
    print is_singleton ? '.' : '#'
    print method

    @nesting += 1
    @last_tracer = tracer

  when 'return','creturn'
    @nesting -= 1 if @nesting > 0

    bucket = (event == 'return' ? :times : :ctimes)
    if start = tracer[bucket].pop
      diff = time - start

      puts unless tracer == @last_tracer
      print '   '*@nesting
      print "<%f>" % (diff/1_000_000.0)
    end
  end
end

class EventMsg < FFI::Struct
  layout :mtype, :long,
         :buf, [:char, 56]
end

module MsgQ
  extend FFI::Library
  ffi_lib 'c'
  attach_function :msgget, [:int, :int], :int
  attach_function :msgrcv, [:int, EventMsg.ptr, :size_t, :long, :int], :int
  attach_function :msgsnd, [:int, EventMsg.ptr, :size_t, :int], :int
end

raise 'invalid pid' unless ARGV[0]

pid = ARGV[0].to_i
funcs = [ARGV[1] || 'sleep']
if ARGV.size > 2
  funcs += ARGV[2..-1]
end

qi = MsgQ.msgget(pid, 0666)
qo = MsgQ.msgget(-pid, 0666)

if qi == -1 || qo == -1
  raise 'invalid pid'
else
  # p [:qi=, qi, :qo=, qo]

  begin
    funcs.each do |func|
      msg = EventMsg.new
      msg[:mtype] = 1
      msg[:buf].to_ptr.put_string(0, "add,#{func}")

      ret = MsgQ.msgsnd(qo, msg, 56, 0)
      Process.kill 'URG', pid
      if ret == -1
        puts FFI::LastError.error
        raise 'msgsnd failed'
      end
    end

    while true
      msg = EventMsg.new
      ret = MsgQ.msgrcv(qi, msg, 56, 0, 0)
      if ret == -1
        puts FFI::LastError.error
        break
      else
        line = msg[:buf].to_ptr.read_string
        process_line(line)
      end
    end
  ensure
    msg = EventMsg.new
    msg[:mtype] = 1
    msg[:buf].to_ptr.put_string(0, "delall")

    ret = MsgQ.msgsnd(qo, msg, 56, 0)
    Process.kill 'URG', pid
    if ret == -1
      puts FFI::LastError.error
    end
  end
end
