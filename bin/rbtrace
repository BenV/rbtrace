#!/usr/bin/env ruby
require 'rubygems'
require 'ffi'

def process_line(line)
  @tracers ||= {}
  @nesting ||= 0
  @last_tracer ||= nil

  time, event, id, *args = line.strip.split(',')
  time = time.to_i
  id = id.to_i
  tracer = @tracers[id] if id > -1

  case event
  when 'add'
    if id == -1
      puts line
    else
      name = args.first
      @tracers[id] = {
        :name => name,
        :times => [],
        :ctimes => []
      }
    end

  when 'remove'
    if id == -1
      puts line
    else
      @tracers.delete(id)
    end

  when 'call','ccall'
    method, is_singleton, klass = *args
    is_singleton = (is_singleton == '1')
    bucket = (event == 'call' ? :times : :ctimes)

    tracer[bucket] << time

    puts
    if @nesting > 0
      print '   '*@nesting
    end
    print klass
    print is_singleton ? '.' : '#'
    print method

    @nesting += 1
    @last_tracer = tracer

  when 'return','creturn'
    @nesting -= 1 if @nesting > 0

    bucket = (event == 'return' ? :times : :ctimes)
    if start = tracer[bucket].pop
      diff = time - start

      if tracer == @last_tracer
        print ' '
      else
        puts
      end
      print '<%f>' % (diff/1_000_000.0)
    end

  when 'slow', 'cslow'
    diff, nesting, method, is_singleton, klass = *args
    nesting = nesting.to_i
    diff = diff.to_i
    is_singleton = (is_singleton == '1')

    if nesting > 0
      print '   '*nesting
    end
    print klass
    print is_singleton ? '.' : '#'
    print method
    print ' '
    puts "<%f>" % (diff/1_000_000.0)
    puts if nesting == 0

  else
    puts "unknown event: #{line}"

  end
end

class EventMsg < FFI::Struct
  layout :mtype, :long,
         :buf, [:char, 56]

  def self.send_cmd(q, str)
    msg = EventMsg.new
    msg[:mtype] = 1
    msg[:buf].to_ptr.put_string(0, str)

    ret = MsgQ.msgsnd(q, msg, 56, 0)
    FFI::LastError.raise if ret == -1
  end

  def self.recv_cmd(q)
    msg = EventMsg.new
    ret = MsgQ.msgrcv(q, msg, 56, 0, 0)
    FFI::LastError.raise if ret == -1

    msg[:buf].to_ptr.read_string
  end
end

module FFI::LastError
  def self.raise(msg=nil)
    errno = error
    exception = Errno::constants.map(&Errno.method(:const_get)).find{ |c| c.const_get(:Errno) == errno }

    raise exception, msg
  end
end

module MsgQ
  extend FFI::Library

  ffi_lib 'c'
  attach_function :msgget, [:int, :int], :int
  attach_function :msgrcv, [:int, EventMsg.ptr, :size_t, :long, :int], :int
  attach_function :msgsnd, [:int, EventMsg.ptr, :size_t, :int], :int
end

raise 'invalid pid' unless ARGV[0]

begin
  raise ArgumentError unless pid = ARGV[0]
  pid = pid.to_i
  raise ArgumentError unless pid > 0
  Process.kill(0,pid)
rescue TypeError, ArgumentError
  raise 'pid required'
rescue Errno::ESRCH
  raise 'invalid pid'
rescue Errno::EPERM
  raise 'could not signal process (run as root)'
end

funcs = [ARGV[1] || 'sleep']
if ARGV.size > 2
  funcs += ARGV[2..-1]
end

qi = MsgQ.msgget(pid, 0666)
qo = MsgQ.msgget(-pid, 0666)

if qi == -1 || qo == -1
  raise 'invalid pid'
else
  begin
    if funcs == ['watch']
      EventMsg.send_cmd(qo, 'watch')
      Process.kill 'URG', pid
    else
      funcs.each do |func|
        EventMsg.send_cmd(qo, "add,#{func}")
        Process.kill 'URG', pid
      end
    end

    while true
      process_line EventMsg.recv_cmd(qi)
    end
  ensure
    EventMsg.send_cmd(qo, funcs == ['watch'] ? 'unwatch' : 'delall')
    Process.kill 'URG', pid
  end
end
