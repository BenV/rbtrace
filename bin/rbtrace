#!/usr/bin/env ruby
require 'rubygems'
require 'ffi'
require 'msgpack'
require 'trollop'

class String
  alias :bytesize :size
end unless ''.respond_to?(:bytesize)

module FFI::LastError
  def self.exception
    Errno::constants.map(&Errno.method(:const_get)).find{ |c| c.const_get(:Errno) == error }
  end
  def self.raise(msg=nil)
    Kernel.raise exception, msg
  end
end

module MsgQ
  extend FFI::Library
  ffi_lib 'c'

  class EventMsg < FFI::Struct
    BUF_SIZE = RUBY_PLATFORM =~ /linux/ ? 256 : 120
    IPC_NOWAIT = 004000

    layout :mtype, :long,
           :buf, [:char, BUF_SIZE]

    def self.send_cmd(q, str)
      msg = EventMsg.new
      msg[:mtype] = 1
      msg[:buf].to_ptr.put_string(0, str)

      ret = MsgQ.msgsnd(q, msg, BUF_SIZE, 0)
      FFI::LastError.raise if ret == -1
    end

    def self.recv_cmd(q, block=true)
      msg = EventMsg.new
      ret = MsgQ.msgrcv(q, msg, BUF_SIZE, 0, block ? 0 : IPC_NOWAIT)
      if ret == -1
        if !block and [Errno::EAGAIN, Errno::ENOMSG].include?(FFI::LastError.exception)
          return nil
        end

        FFI::LastError.raise
      end

      msg[:buf].to_ptr.read_string_length(BUF_SIZE)
    end
  end

  attach_function :msgget, [:int, :int], :int
  attach_function :msgrcv, [:int, EventMsg.ptr, :size_t, :long, :int], :int
  attach_function :msgsnd, [:int, EventMsg.ptr, :size_t, :int], :int
end

class RBTracer
  # Suggest increasing the maximum number of bytes allowed on
  # a message queue to 1MB.
  #
  # This defaults to 16k on Linux, and is hardcoded to 2k in OSX kernel.
  #
  # Returns nothing.
  def self.check_msgmnb
    if File.exists?(msgmnb = "/proc/sys/kernel/msgmnb")
      curr = File.read(msgmnb).to_i
      max = 1024*1024
      cmd = "sysctl kernel.msgmnb=#{max}"

      if curr < max
        if Process.uid == 0
          STDERR.puts "*** running `#{cmd}` for you to prevent losing events (currently: #{curr} bytes)"
          system(cmd)
        else
          STDERR.puts "*** run `sudo #{cmd}` to prevent losing events (currently: #{curr} bytes)"
        end
      end
    end
  end

  # Look for any message queues pairs (pid/-pid) that no longer have an
  # associated process alive, and remove them.
  #
  # Returns nothing.
  def self.cleanup_queues
    if (pids = `ps ax -o pid`.split("\n").map{ |p| p.strip.to_i }).any?
      ipcs = `ipcs -q`.split("\n").grep(/^(q|0x)/).map{ |line| line[/(0x[a-f0-9]+)/,1] }
      ipcs.each do |ipci|
        next if ipci.match(/^0xf/)

        qi = ipci.to_i(16)
        qo = 0xffffffff - qi + 1
        ipco = "0x#{qo.to_s(16)}"

        if ipcs.include?(ipco) and !pids.include?(qi)
          STDERR.puts "*** removing stale message queue pair: #{ipci}/#{ipco}"
          system("ipcrm -Q #{ipci} -Q #{ipco}")
        end
      end
    end
  end

  # Public: The Fixnum pid of the traced process.
  attr_reader   :pid

  # Public: The IO where tracing output is written (default: STDOUT).
  attr_accessor :out

  # The String prefix used on nested method calls (default: ' ').
  attr_accessor :prefix

  # The Boolean flag for showing how long method calls take (default: true).
  attr_accessor :show_duration

  # The Boolean flag for showing the timestamp when method calls start (default: false).
  attr_accessor :show_time

  # Create a new tracer
  #
  # pid - The String of Fixnum process id
  #
  # Returns a tracer.
  def initialize(pid)
    begin
      raise ArgumentError unless pid
      @pid = pid.to_i
      raise ArgumentError unless @pid > 0
      Process.kill(0, @pid)
    rescue TypeError, ArgumentError
      raise ArgumentError, 'pid required'
    rescue Errno::ESRCH
      raise ArgumentError, 'invalid pid'
    rescue Errno::EPERM
      raise ArgumentError, 'could not signal process, are you running as root?'
    end

    Process.kill 'URG', @pid
    sleep 0.25 # wait for process to create msgqs

    @qi = MsgQ.msgget( pid, 0666)
    @qo = MsgQ.msgget(-pid, 0666)

    if @qi == -1 || @qo == -1
      raise ArgumentError, 'pid is not listening for messages, did you `require "rbtrace"`'
    end

    @klasses = {}
    @methods = {}
    @tracers = Hash.new{ |h,k|
      h[k] = {
        :query => nil,
        :times => [],
        :names => [],
        :exprs => {},
        :last => false,
        :arglist => false
      }
    }
    @max_nesting = @nesting = 0
    @last_tracer = nil

    @out = STDOUT
    @prefix = '  '

    @show_time = false
    @show_duration = true

    attach
  end

  # Watch for method calls slower than a threshold.
  #
  # msec - The Fixnum threshold in milliseconds
  #
  # Returns nothing.
  def watch(msec)
    send_cmd(:watch, msec)
  end

  # Turn on the firehose (show all method calls).
  #
  # Returns nothing.
  def firehose
    send_cmd(:firehose)
  end

  # Add tracers for the given list of methods.
  #
  # methods - The String or Array of method selectors to trace.
  #
  # Returns nothing.
  def add(methods)
    Array(methods).each do |func|
      func = func.strip
      next if func.empty?

      if func =~ /^(.+)\((.+)\)$/
        func, args = $1, $2
        args = args.split(',').map{ |a| a.strip }
      end

      send_cmd(:add, func)

      args.each do |arg|
        send_cmd(:addexpr, arg)
      end if args and args.any?
    end
  end

  # Attach to the process.
  #
  # Returns nothing.
  def attach
    send_cmd(:attach, Process.pid)
    if wait_for{ @attached == true }
      STDERR.puts "*** attached to process #{pid}"
    else
      raise ArgumentError, 'process already being traced?'
    end
  end

  # Detach from the traced process.
  #
  # Returns nothing.
  def detach
    begin
      send_cmd(:detach)
    rescue Errno::ESRCH
    end

    puts

    if wait_for{ @attached == false }
      puts
      STDERR.puts "*** detached from process #{pid}"
    else
      puts
      STDERR.puts "*** could not detach cleanly from process #{pid}"
    end
  rescue Errno::EINVAL, Errno::EIDRM
    puts
    STDERR.puts "*** process #{pid} is gone"
  end

  # Process events from the traced process.
  #
  # Returns nothing.
  def recv_loop
    while true
      # block until a message arrives
      process_line(recv_cmd)

      # process any remaining messages
      recv_lines
    end
  rescue Errno::EINVAL, Errno::EIDRM
    # process went away
  end

  # Process events from the traced process, without blocking if
  # there is nothing to do. This is a useful way to drain the buffer
  # so messages do not accumulate in kernel land.
  #
  # Returns nothing.
  def recv_lines
    50.times do
      break unless line = recv_cmd(false)
      process_line(line)
    end
  end

  private

  # Process incoming events until either a timeout or a condition becomes true.
  #
  # time - The Fixnum timeout in seconds.
  # block - The Block that is checked every 50ms until it returns true.
  #
  # Returns true when the condition was met, or false on a timeout.
  def wait_for(time=5)
    wait = 0.05 # polling interval

    (time/wait).to_i.times do
      begin
        recv_lines
        sleep(wait)
        time -= wait

        return true if yield
      rescue Interrupt
        STDERR.puts "*** waiting to detach cleanly (#{time.to_i}s left)"
        retry
      end
    end

    false
  end

  def send_cmd(*cmd)
    begin
      msg = cmd.to_msgpack
      raise ArgumentError, 'command is too long' if msg.bytesize > MsgQ::EventMsg::BUF_SIZE
      MsgQ::EventMsg.send_cmd(@qo, msg)
    rescue Errno::EINTR
      retry
    end
    Process.kill 'URG', @pid
    recv_lines
  end

  def recv_cmd(block=true)
    MsgQ::EventMsg.recv_cmd(@qi, block)
  rescue Errno::EINTR
    # on linux, an incoming signal will interrupt msgrcv()
    # regardless of what SA_RESTART is set to
    retry
  end

  def print(*args)
    @out.print(*args)
  end

  def puts(*args)
    @out.puts(*args)
  end

  def parse_cmd(line)
    unpacker = MessagePack::Unpacker.new
    unpacker.feed(line)

    obj = nil
    unpacker.each{|o| obj = o; break }
    obj
  end

  def process_line(line)
    return unless cmd = parse_cmd(line)
    event = cmd.shift

    case event
    when 'attached'
      tracer_pid = *cmd
      if tracer_pid != Process.pid
        STDERR.puts "*** process #{pid} is already being traced"
        exit!(-1)
      end

      @attached = true
      return

    when 'detached'
      tracer_pid = *cmd
      if tracer_pid != Process.pid
        STDERR.puts "*** process #{pid} detached #{tracer_pid}, but we are #{Process.pid}"
      else
        @attached = false
      end

      return
    end

    unless @attached
      STDERR.puts "*** got #{event} before attaching"
      return
    end

    case event
    when 'mid'
      mid, name = *cmd
      @methods[mid] = name

    when 'klass'
      kid, name = *cmd
      @klasses[kid] = name

    when 'add'
      tracer_id, query = *cmd
      if tracer_id == -1
        STDERR.puts "*** unable to add tracer for #{query}"
      else
        @tracers.delete(tracer_id)
        @tracers[tracer_id][:query] = query
      end

    when 'newexpr'
      tracer_id, expr_id, expr = *cmd
      tracer = @tracers[tracer_id]

      if expr_id > -1
        tracer[:exprs][expr_id] = expr
      end

    when 'exprval'
      tracer_id, expr_id, val = *cmd

      tracer = @tracers[tracer_id]
      expr = tracer[:exprs][expr_id]

      if tracer[:arglist]
        print ', '
      else
        print '('
      end

      print "#{expr}="
      print val
      tracer[:arglist] = true

    when 'call','ccall'
      time, tracer_id, mid, is_singleton, klass = *cmd

      tracer = @tracers[tracer_id]
      klass = @klasses[klass]
      name = klass ? "#{klass}#{ is_singleton ? '.' : '#' }" : ''
      name += @methods[mid] || '(unknown)'

      tracer[:times] << time
      tracer[:names] << name

      if @last_tracer and @last_tracer[:arglist]
        print ')'
        @last_tracer[:arglist] = false
      end
      puts
      if @show_time
        t = Time.at(time/1_000_000)
        print t.strftime("%H:%M:%S.")
        print "%06d " % (time - t.to_f*1_000_000).round
      end
      print @prefix*@nesting if @nesting > 0
      print name

      @nesting += 1
      @max_nesting = @nesting if @nesting > @max_nesting
      @last_tracer = tracer
      tracer[:last] = name

    when 'return','creturn'
      time, tracer_id = *cmd
      tracer = @tracers[tracer_id]

      @nesting -= 1 if @nesting > 0

      if start = tracer[:times].pop
        name = tracer[:names].pop
        diff = time - start
        @last_tracer[:arglist] = false if @last_tracer and @last_tracer[:last] != name

        print ')' if @last_tracer and @last_tracer[:arglist]

        unless tracer == @last_tracer and @last_tracer[:last] == name
          puts
          printf ' '*16 if @show_time
          print @prefix*@nesting if @nesting > 0
          print name
        end
        print ' <%f>' % (diff/1_000_000.0) if @show_duration

        if @nesting == 0 and @max_nesting > 1
          # unless tracer == @last_tracer and @last_tracer[:last] == name
            puts
          # end
        end
      end

      tracer[:arglist] = false

    when 'slow', 'cslow'
      diff, nesting, mid, is_singleton, klass = *cmd

      klass = @klasses[klass]
      name = klass ? "#{klass}#{ is_singleton ? '.' : '#' }" : ''
      name += @methods[mid] || '(unknown)'

      print @prefix*nesting if nesting > 0
      print name
      if @show_duration
        print ' '
        print "<%f>" % (diff/1_000_000.0)
      end
      puts
      puts if nesting == 0

    else
      puts "unknown event: #{line}"

    end
  rescue => e
    STDERR.puts "error on #{event}: #{cmd.inspect}"
    raise e
  end

  def self.run
    check_msgmnb
    cleanup_queues

    parser = Trollop::Parser.new do
      version <<-EOS
rbtrace: like strace, but for ruby code
  version 0.2.8
  (c) 2011 Aman Gupta (tmm1)
  http://github.com/tmm1/rbtrace
EOS

      banner <<-EOS
rbtrace shows you method calls happening inside another ruby process in real time.

to use rbtrace, simply `require "rbtrace"` in your ruby app.

for examples and more information, see http://github.com/tmm1/rbtrace

Usage:

  rbtrace -p <PID>         # trace the given process
  rbtrace -o <FILE>        # write output to file
  rbtrace -t               # show method call start time
  rbtrace -n               # hide duration of each method call
  rbtrace -r 3             # use 3 spaces to nest method calls

Tracers:

  rbtrace --firehose       # trace all method calls
  rbtrace --slow=250       # trace method calls slower than 250ms
  rbtrace --methods a b c  # trace calls to given methods

  rbtrace -c io            # trace common input/output functions
  rbtrace -c eventmachine  # trace common eventmachine functions
  rbtrace -c my.tracer     # trace all methods listed in my.tracer

Method Selectors:

  sleep                    # any instance or class method named sleep
  String#gsub              # specific instance method
  Process.pid              # specific class method
  Dir.                     # any class methods in Dir
  Fixnum#                  # any instance methods of Fixnum

Trace Expressions:

  method(self)             # value of self at method invocation
  method(@ivar)            # value of given instance variable
  method(arg1, arg2)       # value of argument local variables
  method(self.attr)        # value of arbitrary ruby expression
  method(__source__)       # source file/line of callsite


All Options:\n

EOS
      opt :pid,
        "pid of the ruby process to trace",
        :type => :int,
        :short => '-p'

      opt :firehose,
        "show all method calls",
        :short => '-f'

      opt :slow,
        "watch for method calls slower than 250 milliseconds",
        :default => 250,
        :short => '-s'

      opt :methods,
        "method(s) to trace (valid formats: sleep String#gsub Process.pid Kernel# Dir.)",
        :type => :strings,
        :short => '-m'

      opt :start_time,
        "show start time for each method call",
        :short => '-t'

      opt :no_duration,
        "hide time spent in each method call",
        :default => false,
        :short => '-n'

      opt :output,
        "write trace to filename",
        :type => String,
        :short => '-o'

      opt :append,
        "append to output file instead of overwriting",
        :short => '-a'

      opt :prefix,
        "prefix nested method calls with N spaces",
        :default => 2,
        :short => '-r'

      opt :config,
        "config file",
        :type => :strings,
        :short => '-c'
    end

    opts = Trollop.with_standard_exception_handling(parser) do
      raise Trollop::HelpNeeded if ARGV.empty?
      parser.parse(ARGV)
    end

    if out = opts[:output]
      file = File.open(out, opts[:append] ? 'a+' : 'w')
    end

    slow = nil
    firehose = nil
    methods = nil

    if opts[:slow_given]
      slow = opts[:slow]

    elsif opts[:firehose]
      firehose = true

    elsif opts[:methods]
      methods = opts[:methods]

    elsif opts[:config_given]
      methods = []

      Array(opts[:config]).each do |config|
        file = [
          config,
          File.expand_path("../../tracers/#{config}.tracer",__FILE__)
        ].find{ |f| File.exists?(f) }

        unless file
          parser.die :config, '(file does not exist)'
        end

        File.readlines(file).each do |line|
          line.strip!
          next if line =~ /^#/
          next if line.empty?

          methods << line
        end
      end

    else
      $stderr.puts "Error: --slow, --firehose, --methods or --config required."
      $stderr.puts "Try --help for help."
      exit(-1)
    end

    begin
      begin
        tracer = RBTracer.new(opts[:pid])
      rescue ArgumentError => e
        parser.die :pid, "(#{e.message})"
      end

      if slow
        tracer.watch(slow)
      elsif firehose
        tracer.firehose
      elsif methods
        tracer.add(methods)
      end

      if file
        tracer.out = file
      end

      tracer.prefix = ' ' * opts[:prefix]
      tracer.show_duration = !opts[:no_duration]
      tracer.show_time = opts[:start_time]

      begin
        tracer.recv_loop
      rescue Interrupt
      end
    ensure
      if tracer
        tracer.detach
      end
    end
  end
end

RBTracer.run
