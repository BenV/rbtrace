#!/usr/bin/env ruby
require 'rubygems'
require 'ffi'

module RBTracer
  def self.process_line(line)
    @tracers ||= {}
    @nesting ||= 0
    @last_tracer ||= nil

    time, event, id, *args = line.strip.split(',')
    time = time.to_i
    id = id.to_i
    tracer = @tracers[id] if id > -1

    case event
    when 'add'
      if id == -1
        puts line
      else
        name = args.first
        @tracers[id] = {
          :name => name,
          :times => [],
          :names => []
        }
      end

    when 'remove'
      if id == -1
        puts line
      else
        @tracers.delete(id)
      end

    when 'call','ccall'
      method, is_singleton, klass = *args
      is_singleton = (is_singleton == '1')
      name = "#{klass}#{ is_singleton ? '.' : '#' }#{method}"

      tracer[:times] << time
      tracer[:names] << name

      puts
      print '   '*@nesting if @nesting > 0
      print name

      @nesting += 1
      @last_tracer = tracer

    when 'return','creturn'
      @nesting -= 1 if @nesting > 0

      if start = tracer[:times].pop
        name = tracer[:names].pop
        diff = time - start

        unless tracer == @last_tracer
          puts
          print '   '*@nesting if @nesting > 0
          print name
        end
        print ' <%f>' % (diff/1_000_000.0)
        puts if @nesting == 0 and tracer != @last_tracer
      end

    when 'slow', 'cslow'
      diff, nesting, method, is_singleton, klass = *args
      nesting = nesting.to_i
      diff = diff.to_i
      is_singleton = (is_singleton == '1')

      if nesting > 0
        print '   '*nesting
      end
      print klass
      print is_singleton ? '.' : '#'
      print method
      print ' '
      puts "<%f>" % (diff/1_000_000.0)
      puts if nesting == 0

    else
      puts "unknown event: #{line}"

    end
  end
end

class EventMsg < FFI::Struct
  layout :mtype, :long,
         :buf, [:char, 56]

  def self.send_cmd(q, str)
    msg = EventMsg.new
    msg[:mtype] = 1
    msg[:buf].to_ptr.put_string(0, str)

    ret = MsgQ.msgsnd(q, msg, 56, 0)
    FFI::LastError.raise if ret == -1
  end

  def self.recv_cmd(q)
    msg = EventMsg.new
    ret = MsgQ.msgrcv(q, msg, 56, 0, 0)
    FFI::LastError.raise if ret == -1

    msg[:buf].to_ptr.read_string
  end
end

module FFI::LastError
  def self.raise(msg=nil)
    errno = error
    exception = Errno::constants.map(&Errno.method(:const_get)).find{ |c| c.const_get(:Errno) == errno }

    raise exception, msg
  end
end

module MsgQ
  extend FFI::Library

  ffi_lib 'c'
  attach_function :msgget, [:int, :int], :int
  attach_function :msgrcv, [:int, EventMsg.ptr, :size_t, :long, :int], :int
  attach_function :msgsnd, [:int, EventMsg.ptr, :size_t, :int], :int
end

raise 'invalid pid' unless ARGV[0]

begin
  raise ArgumentError unless pid = ARGV[0]
  pid = pid.to_i
  raise ArgumentError unless pid > 0
  Process.kill(0,pid)
rescue TypeError, ArgumentError
  raise 'pid required'
rescue Errno::ESRCH
  raise 'invalid pid'
rescue Errno::EPERM
  raise 'could not signal process (run as root)'
end

funcs = [ARGV[1] || 'sleep']
if ARGV.size > 2
  funcs += ARGV[2..-1]
end

qi = MsgQ.msgget(pid, 0666)
qo = MsgQ.msgget(-pid, 0666)

if qi == -1 || qo == -1
  raise 'invalid pid'
else
  begin
    if funcs.first == 'watch'
      EventMsg.send_cmd(qo, funcs.join(','))
      Process.kill 'URG', pid
    else
      funcs.each do |func|
        EventMsg.send_cmd(qo, "add,#{func}")
        Process.kill 'URG', pid
      end
    end

    while true
      RBTracer.process_line EventMsg.recv_cmd(qi)
    end
  ensure
    EventMsg.send_cmd(qo, funcs.first == 'watch' ? 'unwatch' : 'delall')
    Process.kill 'URG', pid
  end
end
